  %-----------------------------------------------
% DOCUMENT PACKAGES
%-----------------------------------------------
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphics} %inclusion de figures
\usepackage{graphicx} %inclusion de figures
\usepackage{pstricks,pst-node} %Graphiques
\usepackage{tikz} %Tikz !
\usepackage[margin=1.3in]{geometry}
\usepackage[colorlinks=true,linkcolor=black,linktoc=all]{hyperref}
\usepackage[french]{babel}
\usepackage[small, sc, bf, center]{titlesec}
%Packages mathématiques
\usepackage{amsmath} %Equations
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{pifont}
%Packages Tableaux
\usepackage{tabularx} %Tableaux
\usepackage{multirow} %Gestion des lignes
\usepackage{multicol} %Gestion des colones
\usepackage{arydshln} %Lignes en pointillés
\usepackage{fancybox} %Boites
\usepackage{multicol} %Colonnes
\usepackage{array} %Tableaux maths
\usepackage{fancybox}

\usepackage{cleveref}
\usepackage{fancyhdr}
\usepackage{tkz-graph}
\usepackage{csvsimple}
\usepackage{listings}
%\usepackage{subcaption}
%\usepackage{multicol}
%-----------------------------------------------
% DOCUMENT CONFIG
%-----------------------------------------------

% graphicx
\graphicspath{ {images/} }
% Add point after title number
\titleformat{\section}[block]{\sc\bfseries\center\large}{\thesection.}{0.5em}{}
\titleformat{\subsection}[block]{\sc\bfseries\center}{\thesubsection.}{0.5em}{}
\titleformat{\subsubsection}[block]{\sc\bfseries\center}{\thesubsubsection.}{0.5em}{}
% Page number reformat
\pagestyle{fancy}
\fancyfoot[C]{--~\thepage~--}
% Deactivate fancyhdr header
\renewcommand{\headrulewidth}{0pt}
\fancyhead{}
% tikz
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=6pt]
\newcommand{\vertex}{\node[vertex]}
\usetikzlibrary{arrows,petri,topaths,calc}
% listing style
\lstset{
frame=single,
basicstyle=\ttfamily\small,
numbers=left,
%numbersep=5pt,
%font=\ttfamily
}
\newcommand\tab[1][0.65cm]{\hspace*{#1}}
%-----------------------------------------------
% DOCUMENT BODY
%-----------------------------------------------
\begin{document}
\begin{center}
	\textbf{\huge Projet de FOSYMA\\[.5cm] Wumpus Multi-agent}\\[.5cm]
	\vspace{1.5cm}
	\textit{\Large B.Thanh Luong, Gualtiero Mottola}\\
	\vspace{1.5cm}
	\includegraphics{logo}
	\vspace{1.5cm}
	\tableofcontents
\end{center}

\newpage

\section{Introduction}
	Ce projet Consiste a développer une version multi-agent d'un jeu Fortement inspiré de "Hunt the Wumpus"  cette variante du jeu est définie de la façon suivante : un ensemble d'agents en coopération sont placé dans un environnement inconnu on pour mission d'explorer cet environnement et de récupérer un maximum de trésors qui sont disséminé dans cet environnement. Un agent Wumpus se trouve également dans l'environnement, il se déplace aléatoirement et a pour but de gêner l'exploration et la récupération des trésors.
	
\section{Présentation des Agents}
	Les trois type d'agent utilisables pour récolter un maximum de Trésors sur la carte sont les suivants : les Agents Explorateurs qui n'ont pas la possibilité de récupérer des ressources, leur seul but est d'explorer la carte, des Agents Collecteurs qui ont un sac à dos correspondant a un type de trésor (\texttt{TREASURE} ou \texttt{DIAMONDS}) et qui ont une méthode permettant de récupérer ce type de trésor et le placer dans leur sac si celui-ci n'est pas plein. On note que lorsque cette action est exécutée une partie du trésor est perdue. Enfin le dernier type d'agent, l'agent Tanker qui ne peut pas ramasser de trésor mais a un sac a dos de capacité illimité, tous les agents collecteurs ont la possibilité de donner leur trésors à l'agent tanker. Ce sont les quantités présentes dans l'agent Tanker qui seront comptabilisées à la fin de l'exécution.

	\subsection{Comportement des Agents}
	Les comportements de nos trois types d'agents sont tous implémentés sous la forme de \texttt{FSMBehaviours} qui sont des automates finis. La classe offre des méthodes pour enregistrer les états et les transitions qui définissent l'ordre des behaviours.	Chaque état du FSM est un behaviour qui est exécuté selon l'ordre définit par l'utilisateur.\\
	Nous allons décrire dans cette section le comportement principal de chaque agent, puis dans la section suivante la suite de behaviours qui leur permet de communiquer et qui est identique pour tout les types d'agents. Le behaviour Main est le comportement principal de chaque agent, nous avons \texttt{ExploreBehaviour} pour les Agents Explorateurs, \texttt{CollectBehaviour} pour les agents Collecteurs, etc.. En général dans ce comportement, l'agent se déplace, collecte le trésor dans la case où il se trouve ou même ne rien fait mais surtout pas la communication avec les autres.

\begin{lstlisting}
FSMBehaviour fsmBehaviour = new FSMBehaviour();
fsmBehaviour.registerFirstState(new MainBehavior(this),"Main");
fsmBehaviour.registerState(new CheckMailBehavior(this),"Ckm");
fsmBehaviour.registerState(new RequestConnectionBehaviour(this),"Com");
fsmBehaviour.registerState(new SendMapBehaviour(this),"Smp");
fsmBehaviour.registerState(new ReceiveMapBehaviour(this),"Rmp");

fsmBehaviour.registerTransition("Main","Ckm",1); //explore to check mail

fsmBehaviour.registerTransition("Ckm","Com",1); //check mail to start com
fsmBehaviour.registerTransition("Ckm","Smp",2); //check mail to send map

fsmBehaviour.registerTransition("Com","Rmp",1); //com to receive

fsmBehaviour.registerTransition("Smp","Rmp",1); // send to receive
fsmBehaviour.registerTransition("Smp","Main",2); // send to main

fsmBehaviour.registerTransition("Rmp","Main",1); // receive to explore
fsmBehaviour.registerTransition("Rmp","Smp",2); // receive to send

addBehaviour(fsmBehaviour);
\end{lstlisting}
Le schéma ci-dessous représente le comportement composé de nos agents :
\begin{center}
	\qquad \begin{psmatrix}
		& & [mnode=circle] Main &\\
		& [mnode=circle] Ckm & & [mnode=circle] Com\\
		& [mnode=circle] Smp & & [mnode=circle] Rmp
	\end{psmatrix}
	\psset{arrows=->,shortput=nab,arrowsize=0.15}
	\ncline{1,3}{2,2}^{$1$}
	\ncline{2,2}{2,4}^{$1$}
	\ncline{2,2}{3,2}^{$2$}
	\ncline{2,4}{3,4}^{$1$}
	\ncarc[arcangle=15]{3,2}{3,4}^{$1$}
	\ncline{3,2}{1,3}^{$2$}
	\ncline{3,4}{1,3}^{$1$}
	\ncarc[arcangle=15]{3,4}{3,2}^{$2$}
	\psset{doubleline=true}
	\ncline{1,4}{1,3}^{départ}
\end{center}
Nous allons expliquer le comportement principale de chaque type d'agent :
\paragraph{Agent Explorateur :}
Sa mission principale est d'explorer la carte et d'établir une connaissance commune pour tous les agents. Il construit la carte au fur et à mesure dans sa propre table de hachage. Il met à jour sa structure de données personnalisée la disponibilité et la quantité des trésors. À la phase de la communication, tous les agents s'échangent leur carte pour compléter la connaissance. Une fois il a la carte complète, il va tenter d'aller vers les cases aléatoires dans la carte pour mettre à jour les trésors.
\paragraph{Agent Collecteur :} L'agent ne fait que bouger aléatoirement dans la carte et ramasser les trésors de son type quand il n'a pas de carte complète. Si sa carte est complète, il va chercher des trésors dans l'ordre les plus proches de sa position actuelle puis les déposer au tanker.

\paragraph{Agent Tanker :} Au début, il explore la carte comme les Agents Explorateurs pour accélérer le processus d'exploration. Quand il a la carte complète, il fixera sa position grâce à la centralisation dans le graphe pour que les Collecteurs puissent déposer le trésor. Le concept de centralisation sera expliqué dans la section Outils (3.2).

\section{Processus de Communication}

\subsection{Les Processus}
Après chaque action dans l'environnement (\texttt{Main}), l'agent passe au \texttt{CheckMailBehaviour} pour regarder sa boîte aux lettres, s'il reçoit des demandes de communication, il enchaîne les communications et il fusionne sa carte avec celles des agents qui sont 
 de communiquer avec lui. S'il n'a rien dans sa boîte après un certain temps (ce qui est 50ms dans ce cas), il envoie une demande de communication à tout le monde (\texttt{RequestConnectionBehavior}). Les agents peuvent se communiquer si et seulement s'ils sont dans le rayon de communication (c'est-à-dire une distance de 3).\\
\tab Revenons au \texttt{CheckMailBehaviour}, l'agent a reçu des demandes, il passe au \texttt{SendMapBehavior} pour envoyer sa carte, puis \texttt{ReceiveMapBehaviour} pour mettre à jour sa carte, et enfin il revient au \texttt{Main}.\\
\tab S'il diffuse sa demande (\texttt{RequestConnectionBehaviour}), il passe au \texttt{ReceiveMapBehaviour} pour attendre des cartes des autres. Après un certain temps (50ms aussi dans ce comportement), s'il n'en reçoit aucune il revient au \texttt{Main}. Sinon il fusionne sa carte, envoie sa carte mise à jour aux autres, et revient au \texttt{Main}.\\
\tab Les deux cas dans \texttt{CheckMailBehaviour} distinguent bien les comportements suivants de l'agent. C'est pour cela dans le schéma ci-dessus, il y a au moins une flèche sortante de chaque état qui représente les conditions vérifiant les états venant.\\
\tab Dans le cadre du projet, seulement les objets sérialisables et les chaînes de caractères sont autorisés dans la communication. C'est la raison pour laquelle nous utilisons la table de hachage et une structure de données manipulant les trésors qui implémente les objets sérialisables.
\subsection{Les Outils}
\paragraph{Calcul de chemin :} Nous utilisions l'algorithme de Dijkstra pour la recherche du plus court chemin vers les cases non explorée et les trésors.
\paragraph{Centralisation dans le graphe :} Nous plaçons le Tanker dans la centralité intermédiaire du graphe (voir plus \href{https://en.wikipedia.org/wiki/Betweenness_centrality}{ici}). Dans la plupart des cases cette méthode est très efficace. L'inconvénient est si le graphe se décompose en 2 grands sous-graphes de même taille qui se connectent par un noeud unique, une fois le Tanker est placé, les autres agents ne peuvent plus accéder à l'autre partie du graphe.\\
\tab Une autre méthode a été proposée. Nous prenons le noeud ayant les plus descendants comme le centre. Nous allons éviter le blocage. Cependant ce calcul n'est pas uniforme. Si nous voulons synchroniser la position du Tanker, il faudra passer en communication qui double le nombre de messages communiqués.
	
\subsection{Trucs pas implémenté}
{\Huge INTERBLOCAGE !!!}
\subsection{Amélioration}
Nous pourrions réduire le nombre de messages envoyés en stockant les agents communiqués avoir la complétion de la carte.
\section{Conclusion}



	
\end{document}
% !TeX program = xelatex